<!DOCTYPE html>
<html lang="en">

<head>
   <meta charset="UTF-8">
   <meta name="viewport" content="width=device-width, initial-scale=1.0">
   <title>Document</title>
</head>

<body style="background-color: rgb(34, 34, 34);">


   <script>
      /*
      function merger(left, right) {
               const array = []
               while (left.length && right.length) {
                  left[0] < right[0] ? array.push(left.shift()) : array.push(right.shift())
               }
               return [...array, ...left, ...right]
            }
      
            function mergesort(array) {
               if (array.length <= 1) return array;
               const middle = array.length / 2;
               const left = mergesort(array.slice(0, middle));
               const right = mergesort(array.slice(middle));
               return merger(left, right)
            }
-------------------------------------------------
            function quicksort(array) {
               if (array.length <= 1) return array;
               const pivot = array.shift()
               let left = []
               let right = []
               array.map(item => item < pivot ? left.push(item) : right.push(item))
               return [...quicksort(left), pivot, ...quicksort(right)]
            }
      
      */
      // 031 Lowest Common Ancestor (Difficulty = ___)


      function lowestCommonAncestor_bejaras(root) {
         if (root.left === null && root.right === null) {
            const array = []
            array.push(root.data)
            return array
         }
         const leftS = lowestCommonAncestor_bejaras(root.left)
         const rightS = lowestCommonAncestor_bejaras(root.right)
         return [...leftS, ...rightS, root.data]
      }


      function lowestCommonAncestor(root, p, q) {
         if (!root) return

         if (root.data === p || root.data === q) {
            return root
         }

         let left = lowestCommonAncestor(root.left, p, q)
         let right = lowestCommonAncestor(root.right, p, q)

         // console.log(left, right);
         if (left && right) return root

         return left ? left : right
      }








      /*
            function lowestCommonAncestor_bejaras(root) {
               if (root.left == null || root.right == null) {
                  let arr = []
                  arr.push(root.data)
                  return arr
               }
      
               let leftNode = this.lowestCommonAncestor_bejaras(root.left);
               let rightNode = this.lowestCommonAncestor_bejaras(root.right);
               return [...leftNode, ...rightNode, root.data]
            }
      
      
            function lowestCommonAncestor(root, p, q) {
               // console.log(root);
      
               if (root == null) {
                  return null;
               }
               if (root.data == p || root.data == q) {
                  return root;
               }
               let leftNode = this.lowestCommonAncestor(root.left, p, q);
               let rightNode = this.lowestCommonAncestor(root.right, p, q);
      
               if (leftNode && rightNode) {
                  return root;
               }
               if (!leftNode && !rightNode) return null;
               return leftNode ? leftNode : rightNode;
            }
      */







      // 028 Is This a Binary Search Tree_ (Difficulty = __)



      // function is_binary_tree(headP, val = headP.value) {
      //    if (headP.left === undefined || headP.right === undefined) {
      //       return
      //    }
      //    console.log(headP.left.value, headP.right.value, val);
      //    let left = headP.left
      //    let right = headP.right
      //    is_binary_tree(left, headP.value)
      //    is_binary_tree(right, headP.value)
      //    return 'f'
      // }


      function isValidBST(node, min = null, max = null) {

         if (!node) return true

         if (max !== null && node.data >= max) {
            return false
         }

         if (min !== null && node.data <= min) {
            return false
         }

         const leftSide = isValidBST(node.left, min, node.data)
         const rightSide = isValidBST(node.right, node.data, max)
         return leftSide && rightSide
      }


      // console.log(node, min, max);

      // if (!node) return true;
      // if (max !== null && node.data >= max) {
      //    return false;
      // }
      // if (min !== null && node.data <= min) {
      //    return false;
      // }
      // const leftSide = this.isValidBST(node.left, min, node.data);
      // const rightSide = this.isValidBST(node.right, node.data, max);

      // return leftSide && rightSide;


      const nodeA_7 = new BNode(7,)
      const nodeA_6 = new BNode(6,)
      const nodeA_2 = new BNode(2,)
      const nodeA_9 = new BNode(9,)
      const nodeA_8 = new BNode(8,)
      const nodeA_3 = new BNode(3, nodeA_6, nodeA_7)
      const nodeA_4 = new BNode(4, nodeA_9, nodeA_2)
      const nodeA_1 = new BNode(1, nodeA_3, nodeA_8)
      const nodeA_5 = new BNode(5, nodeA_1, nodeA_4)
      const headA = nodeA_5

      console.log('returned', lowestCommonAncestor_bejaras(headA))
      console.log('returned', lowestCommonAncestor(headA, 8, 7))
      // console.log(lowestCommonAncestor(headA, 1, 5))
      // console.log(lowestCommonAncestor(headA, 2, 2))


      const nodeB_3 = new BNode(3,)
      const nodeB_0 = new BNode(0,)
      const nodeB_2 = new BNode(2,)
      const nodeB_1 = new BNode(1, nodeB_0, nodeB_3)
      const nodeB_4 = new BNode(4, nodeB_1, nodeB_2)
      const headB = nodeB_4


      const nodeC_6 = new BNode(6, null, null)
      const nodeC_3 = new BNode(3, null, null)
      const nodeC_2 = new BNode(2, null, null)
      const nodeC_0 = new BNode(0, null, null)
      const nodeC_5 = new BNode(5, nodeC_3, nodeC_6)
      const nodeC_1 = new BNode(1, nodeC_0, nodeC_2)
      const nodeC_4 = new BNode(4, nodeC_1, nodeC_5)
      const headC = nodeC_4

      // console.log(isValidBST(headA));
      // console.log(isValidBST(headB))
      // console.log(isValidBST(headC))


      function BNode(value, childA = null, childB = null) {
         this.data = value
         this.left = childA //Node
         this.right = childB //Node
      }


      // 026 N-th Element of a Linked List (Difficulty = __)
      function Node(value, child) {
         this.value = value
         this.child = child //Node
      }
      /*
            const node_1 = new Node(1, null)
            const node_2 = new Node(2, node_1)
            const node_3 = new Node(3, node_2)
            const node_4 = new Node(4, node_3)
            const node_5 = new Node(5, node_4)
            const head = node_5
      */

      function nth_from_end(head, n) {
         let pointer = head;
         let count = 1
         while (pointer.child !== null) {
            pointer = pointer.child
            count++
         }
         pointer = head;

         for (let index = 0; count - n !== index; index++) {
            pointer = pointer.child
         }
         return pointer.value;
      }


      // console.log(nth_from_end(head, 3))


      /*
            function Node_2() {
               const newplayer = Object.create(null)
               newplayer.value = 7
               newplayer.child = undefined //Node
               return newplayer
            }
      
            function Node_3() {
               const newplayer = {
                  value: 7,
                  child: undefined //Node
               }
               return newplayer
            }
      */

      // 023 Rotating 2D Array (inplace / Out-of-Place Solution)

      function rotating_inplace(array, n) {
         for (let x = 0; x < n; x++) {
            for (let y = n - 1; y >= 0; y--) {
               array[x].push(array[y].shift())
            }
         }
         return array
      }



      function rotating_outofplace(array, n) {
         const newArray = []
         for (let y = 0; y < n; y++) {
            const row = []
            for (let x = 0; x < n; x++) {
               row.unshift(array[x][y])
            }
            newArray.push(row)
         }
         return newArray
      }

      // console.log(rotating_inplace(
      //    [
      //       [1, 2, 3],
      //       [4, 5, 6],
      //       [7, 8, 9]
      //    ], 3
      // ));

      // console.log(rotating_outofplace(
      //    [
      //       [1, 2, 3],
      //       [4, 5, 6],
      //       [7, 8, 9]
      //    ], 3
      // ));




      // 019 Find Where to Expand in Minesweeper (Difficulty = ___)
      function Minesweeper_reveal(field, num_rows, num_cols, given_i, given_j) {

         if (field[given_i][given_j] !== 0) return field

         const check_queue = []

         // put initial value 
         field[given_i][given_j] = -2
         check_queue.push([given_i, given_j])

         while (check_queue.length) {
            const [x, y] = check_queue.shift();
            // ..calculate
            for (let index_x = x - 1; index_x < x + 2; index_x++) {
               for (let index_y = y - 1; index_y < y + 2; index_y++) {
                  if (field[index_x] !== undefined && field[index_y] !== undefined && field[index_x][index_y] === 0) {
                     field[x][y] = -2
                     check_queue.push([index_x, index_y])
                  }
               }
            }
         }
         return field
      }



      // console.log(
      //    Minesweeper_reveal([[-1, 1, 0, 0, 0], [1, 2, 1, 2, 1], [0, 1, -1, 2, -1], [0, 1, 1, 2, 1], [0, 0, 0, 0, 0]
      //    ],
      //       5, 5,
      //       0, 3)
      // )


      /*
                                 [-1,1, 0,0, 0],
                                 [ 1,2, 1,2, 1],
                                 [ 0,1,-1,2,-1],
                                 [ 0,1, 1,2, 1],
                                 [ 0,0, 0,0, 0]
      */

      // 017 Assign Numbers in Minesweeper (Difficulty = __)
      function Minesweeper(bombs, rows, cols) {
         const array = [[]];

         //init
         for (let index_x = 0; index_x < rows; index_x++) {
            array[index_x] = []
            for (let index_y = 0; index_y < cols; index_y++) {
               array[index_x][index_y] = 0
            }
         }

         //mark fields
         let index = 0
         while (bombs.length !== 0 && index <= bombs.length) {
            let x = bombs[0][0]
            let y = bombs[0][1]

            //set bomb
            array[x][y] = -1

            //right mark
            if (y !== rows) array[x][y + 1]++;

            //left mark
            if (y !== 0 && array[x][y - 1] !== -1) array[x][y - 1]++;


            //mark belove
            if (y !== rows && array[x + 1]) {

               if (array[x + 1][y] !== -1)
                  array[x + 1][y]++;

               if (y !== 0) {
                  array[x + 1][y - 1]++
               }
               if (y !== rows) {
                  array[x + 1][y + 1]++
               }
            }


            //mark above
            if (y !== rows && array[x - 1]) {

               if (array[x - 1][y] !== -1)
                  array[x - 1][y]++

               if (y !== 0) {
                  array[x - 1][y - 1]++
               }
               if (y !== rows) {
                  array[x - 1][y + 1]++
               }
            }


            bombs.shift()
         }


         console.log(array);


      }

      // Minesweeper([[5, 5], [6, 5]], 10, 10)



      // 014 One Away Strings (Difficulty = ___)
      //deleting adding changing
      function oneway(a, b) {
         if (Math.abs(a.length - b.length) > 1) return false
         let res = true;
         const obj = {}
         a.split('').map(item => obj[item] = item)
         b.split('').map(item => {
            if (obj[item]) { delete obj[item] } else { obj[item] = item }
         })
         console.log(obj);
         //change one
         if (Object.keys(obj).length > 2) return false
         return res
      }

      // const array_a = 'xyz'
      // const array_b = 'xyaz'

      // console.log(oneway(array_a, array_b))


      // 012 Non-Repeating Character (Difficulty = __)
      function non_repeating(str) {
         const obj = {}
         let pointer = null
         str.split('').map(item => {
            obj[item] = obj[item] ? obj[item] + 1 : obj[item] = 1;
         });
         for (const iterator in obj) {
            if (obj[iterator] === 1) {
               pointer = iterator
               break;
            }
         }
         console.log(obj);
         console.log(pointer);
      }

      // non_repeating('aabcb')  //c
      // non_repeating('xxyz')   //y
      // non_repeating('aabb')   //null


      //**************01 Introduction and Problem Solving Tips***********
      // const array_A = [1, 2, 3, 4, 5, 6, 7]
      // const array_B = [3, 4, 5, 6, 7, 1, 2]

      // 010 Is One Array a Rotation of Another_ (Difficulty = __)
      function function_rot(a, b) {
         obj_b = {}
         let rotated = true
         array_B.map(item => obj_b[item] = item)
         array_A.map(item => rotated = obj_b[item] !== undefined && rotated)
         console.log(rotated);
      }
      // function_rot(array_A, array_B)

      // console.log(5 % 7);


      // 008 Common Elements in Two Sorted Arrays (Difficulty = __)


      // const array_A = [1, 3, 4, 6, 7, 9, 11, 12, 15, 20]
      // const array_B = [1, 2, 4, 5, 9, 10, 11, 12, 20]
      function commonE_(left, right) {
         // const obj = {}
         let p1 = 0
         let p2 = 0
         const res = []
         while (p1 < left.length && p2 < right.length) {
            if (left[p1] == right[p2]) {
               res.push(left[p1])
               p1++
               p2++
            } else {
               if (left[p1] > right[p2]) {
                  p2++
               } else {
                  p1++
               }
            }
         }

         // console.log(res);
         // console.log(obj);
         // console.log('done');
      }
      // commonE_(array_A, array_B)



      // my solution
      // const array_A = [1, 3, 4, 6, 7, 9, 11, 12, 5]
      // const array_B = [1, 2, 4, 5, 9, 10, 12, 11, 6]
      function commonE(left, right) {
         const obj = {}
         const res = []
         while (left.length && right.length) {
            const a = left.shift()
            const b = right.shift()
            if (a === b) {
               res.push(a)
            } else {
               if (!obj[a]) { obj[a] = 1 } else { obj[a]++ }
               if (!obj[b]) { obj[b] = 1 } else { obj[b]++ }
               if (obj[a] === 2) res.push(a)
               if (obj[b] === 2) res.push(b)
            }
         }
         console.log(res);
         console.log(obj);
         console.log('done');
      }
      // commonE(array_A, array_B)


      // 006 Most Frequently Occurring Item in an Array (Difficulty = _)


      // solution with for 
      // const array = [1, 3, 1, 3, 2, 1, 1, 1, 7, 7, 7, 7, 7, 7, 7, 4, 3, 2, 2, 22, 2, 2, 2, 2, 2]
      // const obj = {}
      // let max = 0;
      // let maxItem
      /*
       for (let index = 0; index < array.length; index++) {
 
          if (obj[array[index]]) {
             obj[array[index]] = obj[array[index]] + 1;
          } else {
             obj[array[index]] = 1
          }
          if (obj[array[index]] > max) {
             max = obj[array[index]]
             maxItem = array[index]
          }
       }
       */
      // console.log(obj);
      // console.log(maxItem, max);



      //solution with map
      // const freqArray = [1, 3, 1, 3, 2, 1]
      function exercise_1(array) {
         const obj = {};
         let maxValue = -1;
         let maxKey
         array.map(key => {
            if (!obj[key]) {
               obj[key] = 1
            } else {
               obj[key]++
            }
            if (maxValue < obj[key]) {
               maxValue = obj[key]
               maxKey = key
            }
         })
         console.log(obj);
         console.log(maxKey, maxValue);
      }
      // console.log(exercise_1(freqArray));







      //find three integers that multiply to 20
      function multiply_3x(array, num) {
         const result = []
         array.map((item, index) => {
            let sliced = array.slice(index + 1)
            let res = multiply(sliced, num / item);
            if (res) result.push([...res, item])
         })
         return result
      }


      //find two integers that multiply to 20
      function multiply(array, num) {
         // console.log(array, num);

         const obj = {}
         let res = []

         array.map(item => {
            let div = num / item

            if (obj[div]) {
               res.push(obj[div], item);
            }

            obj[item] = item
         })
         if (res.length) return res
      }


      // const array = [2, 4, 1, 6, 5, 40, -1, 2]
      // console.log(multiply(array, 20));
      // console.log(multiply_3x(array, 20));
      // console.log(quicksort(array));
      // console.log(mergesort(array));






      //merge sort
      function merger(left, right) {
         const array = []
         while (left.length && right.length) {
            left[0] < right[0] ? array.push(left.shift()) : array.push(right.shift())
         }
         return [...array, ...left, ...right]
      }

      function mergesort(array) {
         if (array.length <= 1) return array;
         const middle = array.length / 2;
         const left = mergesort(array.slice(0, middle));
         const right = mergesort(array.slice(middle));
         return merger(left, right)
      }



      //quick sort
      function quicksort(array) {
         if (array.length <= 1) return array;
         const pivot = array.shift()
         let left = []
         let right = []
         array.map(item => item < pivot ? left.push(item) : right.push(item))
         return [...quicksort(left), pivot, ...quicksort(right)]
      }


   </script>


</body>

</html>